## API Report File for "cpcall"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export type AnyCaller = {
    (...args: any[]): Promise<any>;
    [key: string]: AnyCaller;
};

// @public (undocumented)
export type AnyEmitter = {
    (...args: any[]): void;
    [key: string]: AnyCaller;
};

// @public (undocumented)
export type CalleeFrame = Frame.Return | Frame.ReturnPromise | Frame.Resolve | Frame.Reject | Frame.Throw | Frame.EndServe;

// @public (undocumented)
export type CallerFrame = Frame.Call | Frame.Exec | Frame.EndCall;

// @public (undocumented)
export enum CallerStatus {
    callable = 0,
    ended = 2,
    ending = 1,
    finished = 3
}

// @public (undocumented)
export class CpCall extends CpCallBase {
    constructor(frameSource: CpcFrameSource<RpcFrame>, config?: CpCallOption);
    static call<T extends (...args: any[]) => any>(proxyObj: T, ...args: Parameters<T>): ReturnType<T>;
    static exec<T extends (...args: any[]) => any>(proxyObj: T, ...args: Parameters<T>): void;
    genCaller(opts?: GenCallerOpts): AnyCaller;
    // (undocumented)
    genCaller(base: string, opts?: GenCallerOpts): AnyCaller;
    // (undocumented)
    genCaller<R extends object>(base: string, opts?: GenCallerOpts): MakeCallers<R>;
    // (undocumented)
    genCaller<R extends object>(opts?: GenCallerOpts): MakeCallers<R>;
    setObject(obj?: object): void;
    setObject(obj: object): void;
}

// @public
export abstract class CpCallBase {
    constructor(frameSource: CpcFrameSource<RpcFrame>, config: CpCallBaseOption);
    call(...args: any[]): Promise<any>;
    get callerStatus(): CallerStatus;
    close(): Promise<void>;
    // (undocumented)
    get closed(): boolean;
    dispose(reason?: any): void;
    endCall(): Promise<void>;
    endServe(): Promise<void>;
    exec(...args: any[]): void;
    readonly onCallEnd: Promise<void>;
    readonly onClose: Promise<void>;
    readonly onServeEnd: Promise<void>;
    // (undocumented)
    protected get responsePromiseNum(): number;
    get serverStatus(): ServerStatus;
}

// @public (undocumented)
export interface CpCallBaseOption {
    // (undocumented)
    disableCall?: boolean;
    // (undocumented)
    disableServe?: boolean;
    // (undocumented)
    onCall(args: unknown[]): any;
}

// @public (undocumented)
export interface CpCallOption {
    // (undocumented)
    disableCall?: boolean;
    // (undocumented)
    disableServe?: boolean;
    // (undocumented)
    serveObject?: object;
}

// @public
export type CpcController<T = RpcFrame> = {
    nextFrame(frame: T): void;
    endFrame(error?: any): void;
};

// @public
export class CpcError extends Error {
}

// @public
export class CpcFailAsyncRespondError extends Error {
}

// @public
export class CpcFailRespondError extends Error {
    constructor();
}

// @public
export type CpcFrameSource<T = RpcFrame> = {
    sendFrame(frame: T): void;
    init(controller: CpcController<T>): void;
    close(): void | Promise<void>;
    dispose(reason?: any): void;
};

// @public
export function createJbodStreamFrameSource(ctrl: CpcFrameSource<Uint8Array>): CpcFrameSource<RpcFrame>;

// Warning: (ae-forgotten-export) The symbol "Duplex" needs to be exported by the entry point index.d.ts
//
// @public
export function createSocketCpc(duplex: Duplex, option?: CpCallOption): CpCall;

// Warning: (ae-forgotten-export) The symbol "WebSocket_2" needs to be exported by the entry point index.d.ts
//
// @public
export function createWebSocketCpc(websocket: WebSocket_2, option?: CpCallOption): CpCall;

// @public
export function createWebsocketCpcOnOpen(websocket: WebSocket_2, option?: CpCallOption): Promise<CpCall>;

// @public
export function createWebStreamCpc(stream: WebStreamSuite): CpCall;

// @public (undocumented)
export namespace Frame {
    // (undocumented)
    export type Call = {
        type: FrameType.call;
        args: any[];
    };
    // (undocumented)
    export type EndCall = {
        type: FrameType.endCall;
    };
    // (undocumented)
    export type EndServe = {
        type: FrameType.endServe;
    };
    // (undocumented)
    export type Exec = {
        type: FrameType.exec;
        args: any[];
    };
    // (undocumented)
    export type Reject = {
        type: FrameType.reject;
        id: number;
        value: any;
    };
    // (undocumented)
    export type Resolve = {
        type: FrameType.resolve;
        id: number;
        value: any;
    };
    // (undocumented)
    export type ResponseError = {
        type: FrameType.error;
        code: number;
    };
    // (undocumented)
    export type Return = {
        type: FrameType.return;
        value: any;
    };
    // (undocumented)
    export type ReturnPromise = {
        type: FrameType.promise;
        id: number;
    };
    // (undocumented)
    export type Throw = {
        type: FrameType.throw;
        value: any;
    };
}

// @public
export enum FrameType {
    // (undocumented)
    call = 1,
    // (undocumented)
    endCall = 254,
    // (undocumented)
    endServe = 255,
    // (undocumented)
    error = 7,
    // (undocumented)
    exec = 2,
    // (undocumented)
    promise = 8,
    // (undocumented)
    reject = 10,
    // (undocumented)
    resolve = 9,
    // (undocumented)
    return = 11,
    // (undocumented)
    throw = 12
}

// @public (undocumented)
export type GenCallerOpts = {
    keepThen?: boolean;
};

// @public (undocumented)
export type MakeCallers<T extends object, E extends object = {}> = E & {
    [Key in keyof T as T[Key] extends object ? Key : never]: T[Key] extends object ? MakeCallers<T[Key], E> : never;
} & (T extends (...args: infer A) => infer R ? (...args: A) => Promise<Awaited<R>> : {});

// @public (undocumented)
export type MakeEmitter<T extends object, E extends object = {}> = E & {
    [Key in keyof T as T[Key] extends object ? Key : never]: T[Key] extends object ? MakeCallers<T[Key], E> : never;
} & (T extends (...args: infer A) => any ? (...args: A) => void : {});

// @public
export function manualDefineObject(Class: new (...args: any[]) => any, serviceDecorator: RpcDecorator, define?: Record<string, RpcDecorator[]>): void;

// @public
export type ParseObjectOption = {
    cmd?: string;
};

// @public
export class RemoteCallError extends Error {
    constructor(message: string, option?: {
        cause?: any;
    });
    // (undocumented)
    code?: any;
}

// @public (undocumented)
export type RpcDecorator<A extends any[] = any[], R = any> = (input: unknown, context: {
    name: string | symbol;
    metadata: object;
}) => void;

// @public (undocumented)
export const rpcExclude: RpcDecorator;

// @public (undocumented)
export function RpcExposed(): RpcDecorator;

// @public (undocumented)
export type RpcFrame = Frame.Return | Frame.ReturnPromise | Frame.Resolve | Frame.Reject | Frame.Throw | Frame.EndServe | Frame.Call | Frame.Exec | Frame.EndCall | Frame.ResponseError;

// @public
export function RpcInterceptCall<T extends any[], A extends any[]>(interceptor: (args: T) => A): RpcDecorator<A>;

// @public
export function RpcInterceptReturn<T, R>(interceptor?: (result: R) => T): RpcDecorator<any[], R>;

// @public (undocumented)
export function RpcService(mode?: ServiceDefineMode): (input: new (...args: any[]) => Object, context: ClassDecoratorContext) => void;

// @public (undocumented)
export type ServeFnConfig = {
    interceptCall?(args: any[]): any[];
    interceptReturn?(data: any): any;
};

// @public (undocumented)
export enum ServerStatus {
    ended = 1,
    finished = 2,
    serving = 0
}

// @public (undocumented)
export enum ServiceDefineMode {
    // (undocumented)
    exclude = 1,
    // (undocumented)
    include = 0
}

// @public
export class UnregisteredMethodError extends Error {
    constructor(cmd: any);
}

// @public (undocumented)
export type WebStreamSuite = {
    readable: ReadableStream_2<Uint8Array>;
    writable: WritableStream_2<Uint8Array>;
};

// Warnings were encountered during analysis:
//
// dist/mod.d.ts:373:5 - (ae-forgotten-export) The symbol "ReadableStream_2" needs to be exported by the entry point index.d.ts
// dist/mod.d.ts:374:5 - (ae-forgotten-export) The symbol "WritableStream_2" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
