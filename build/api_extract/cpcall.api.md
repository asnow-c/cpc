## API Report File for "cpcall"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Duplex } from 'node:stream';

// @public (undocumented)
type AnyCaller = {
    (...args: any[]): Promise<any>;
    [key: string]: AnyCaller;
};

// @public (undocumented)
type AnyEmitter = {
    (...args: any[]): void;
    [key: string]: AnyCaller;
};

// @public (undocumented)
type CalleeFrame = Frame.Return | Frame.ReturnPromise | Frame.Resolve | Frame.Reject | Frame.Throw | Frame.EndServe;

// @public (undocumented)
type CallerFrame = Frame.Call | Frame.Exec | Frame.EndCall;

// @public (undocumented)
enum CallerStatus {
    callable = 0,
    ended = 2,
    ending = 1,
    finished = 3
}

declare namespace core {
    export {
        AnyCaller,
        AnyEmitter,
        CalleeFrame,
        CallerFrame,
        CallerStatus,
        CpCall,
        CpCallBase,
        CpCallOption,
        CpcController,
        CpcError,
        CpcFailAsyncRespondError,
        CpcFailRespondError,
        CpcFrameSource,
        Frame,
        FrameType,
        GenCallerOpts,
        MakeCallers,
        MakeEmitter,
        ParseObjectOption,
        RemoteCallError,
        RpcDecorator,
        RpcExposed,
        RpcFrame,
        RpcInterceptCall,
        RpcInterceptReturn,
        RpcService,
        ServeFnConfig,
        ServerStatus,
        ServiceDefineMode,
        UnregisteredMethodError,
        createJbodStreamFrameSource,
        manualDefineObject,
        rpcExclude
    }
}

// @public (undocumented)
class CpCall extends CpCallBase {
    static call<T extends (...args: any[]) => any>(proxyObj: T, ...args: Parameters<T>): ReturnType<T>;
    static exec<T extends (...args: any[]) => any>(proxyObj: T, ...args: Parameters<T>): void;
    genCaller(opts?: GenCallerOpts): AnyCaller;
    // (undocumented)
    genCaller(base: string, opts?: GenCallerOpts): AnyCaller;
    // (undocumented)
    genCaller<R extends object>(base: string, opts?: GenCallerOpts): MakeCallers<R>;
    // (undocumented)
    genCaller<R extends object>(opts?: GenCallerOpts): MakeCallers<R>;
    // (undocumented)
    protected onCall(rawArgs: any[]): any;
    setObject(obj?: object): void;
    setObject(obj: object): void;
}

// @public
abstract class CpCallBase {
    constructor(frameSource: CpcFrameSource<RpcFrame>, opts?: CpCallOption);
    call(...args: any[]): Promise<any>;
    get callerStatus(): CallerStatus;
    close(): Promise<void>;
    // (undocumented)
    get closed(): boolean;
    dispose(reason?: any): void;
    endCall(): Promise<void>;
    endServe(): Promise<void>;
    exec(...args: any[]): void;
    // (undocumented)
    protected abstract onCall(rawArgs: any[]): any;
    readonly onCallEnd: Promise<void>;
    readonly onClose: Promise<void>;
    readonly onServeEnd: Promise<void>;
    // (undocumented)
    protected get responsePromiseNum(): number;
    get serverStatus(): ServerStatus;
}

// @public (undocumented)
interface CpCallOption {
    // (undocumented)
    disableCall?: boolean;
    // (undocumented)
    disableServe?: boolean;
}

// @public
type CpcController<T = RpcFrame> = {
    nextFrame(frame: T): void;
    endFrame(error?: any): void;
};

// @public
class CpcError extends Error {
}

// @public
class CpcFailAsyncRespondError extends Error {
}

// @public
class CpcFailRespondError extends Error {
    constructor();
}

// @public
type CpcFrameSource<T = RpcFrame> = {
    sendFrame(frame: T): void;
    init(controller: CpcController<T>): void;
    close(): void | Promise<void>;
    dispose(reason?: any): void;
};

// @public
function createJbodStreamFrameSource(ctrl: CpcFrameSource<Uint8Array>): CpcFrameSource<RpcFrame>;

// @public
function createSocketCpc(duplex: Duplex): CpCall;

// Warning: (ae-forgotten-export) The symbol "WebSocket_2" needs to be exported by the entry point index.d.ts
//
// @public
function createWebSocketCpc(websocket: WebSocket_2): CpCall;

// @public
function createWebsocketCpcOnOpen(websocket: WebSocket_2): Promise<CpCall>;

// @public
function createWebStreamCpc(stream: WebStreamSuite): CpCall;

// @public (undocumented)
namespace Frame {
    // (undocumented)
    type Call = {
        type: FrameType.call;
        args: any[];
    };
    // (undocumented)
    type EndCall = {
        type: FrameType.endCall;
    };
    // (undocumented)
    type EndServe = {
        type: FrameType.endServe;
    };
    // (undocumented)
    type Exec = {
        type: FrameType.exec;
        args: any[];
    };
    // (undocumented)
    type Reject = {
        type: FrameType.reject;
        id: number;
        value: any;
    };
    // (undocumented)
    type Resolve = {
        type: FrameType.resolve;
        id: number;
        value: any;
    };
    // (undocumented)
    type ResponseError = {
        type: FrameType.error;
        code: number;
    };
    // (undocumented)
    type Return = {
        type: FrameType.return;
        value: any;
    };
    // (undocumented)
    type ReturnPromise = {
        type: FrameType.promise;
        id: number;
    };
    // (undocumented)
    type Throw = {
        type: FrameType.throw;
        value: any;
    };
}

// @public
enum FrameType {
    // (undocumented)
    call = 1,
    // (undocumented)
    endCall = 254,
    // (undocumented)
    endServe = 255,
    // (undocumented)
    error = 7,
    // (undocumented)
    exec = 2,
    // (undocumented)
    promise = 8,
    // (undocumented)
    reject = 10,
    // (undocumented)
    resolve = 9,
    // (undocumented)
    return = 11,
    // (undocumented)
    throw = 12
}

// @public (undocumented)
type GenCallerOpts = {
    keepThen?: boolean;
};

// @public (undocumented)
type MakeCallers<T extends object, E extends object = {}> = E & {
    [Key in keyof T as T[Key] extends object ? Key : never]: T[Key] extends object ? MakeCallers<T[Key], E> : never;
} & (T extends (...args: infer A) => infer R ? (...args: A) => Promise<Awaited<R>> : {});

// @public (undocumented)
type MakeEmitter<T extends object, E extends object = {}> = E & {
    [Key in keyof T as T[Key] extends object ? Key : never]: T[Key] extends object ? MakeCallers<T[Key], E> : never;
} & (T extends (...args: infer A) => any ? (...args: A) => void : {});

// @public
function manualDefineObject(Class: new (...args: any[]) => any, serviceDecorator: RpcDecorator, define?: Record<string, RpcDecorator[]>): void;

declare namespace node {
    export {
        AnyCaller,
        AnyEmitter,
        CalleeFrame,
        CallerFrame,
        CallerStatus,
        CpCallBase,
        CpCallOption,
        CpcController,
        CpcError,
        CpcFailAsyncRespondError,
        CpcFailRespondError,
        CpcFrameSource,
        Frame,
        FrameType,
        GenCallerOpts,
        MakeCallers,
        MakeEmitter,
        ParseObjectOption,
        RemoteCallError,
        RpcDecorator,
        RpcExposed,
        RpcFrame,
        RpcInterceptCall,
        RpcInterceptReturn,
        RpcService,
        ServeFnConfig,
        ServerStatus,
        ServiceDefineMode,
        UnregisteredMethodError,
        createJbodStreamFrameSource,
        manualDefineObject,
        rpcExclude,
        CpCall,
        createSocketCpc
    }
}

// @public
type ParseObjectOption = {
    cmd?: string;
};

// @public
class RemoteCallError extends Error {
    // (undocumented)
    code?: any;
}

// @public (undocumented)
type RpcDecorator<A extends any[] = any[], R = any> = (input: unknown, context: {
    name: string | symbol;
    metadata: object;
}) => void;

// @public (undocumented)
const rpcExclude: RpcDecorator;

// @public (undocumented)
function RpcExposed(): RpcDecorator;

// @public (undocumented)
type RpcFrame = Frame.Return | Frame.ReturnPromise | Frame.Resolve | Frame.Reject | Frame.Throw | Frame.EndServe | Frame.Call | Frame.Exec | Frame.EndCall | Frame.ResponseError;

// @public
function RpcInterceptCall<T extends any[], A extends any[]>(interceptor: (args: T) => A): RpcDecorator<A>;

// @public
function RpcInterceptReturn<T, R>(interceptor?: (result: R) => T): RpcDecorator<any[], R>;

// @public (undocumented)
function RpcService(mode?: ServiceDefineMode): (input: new (...args: any[]) => Object, context: ClassDecoratorContext) => void;

// @public (undocumented)
type ServeFnConfig = {
    interceptCall?(args: any[]): any[];
    interceptReturn?(data: any): any;
};

// @public (undocumented)
enum ServerStatus {
    ended = 1,
    finished = 2,
    serving = 0
}

// @public (undocumented)
enum ServiceDefineMode {
    // (undocumented)
    exclude = 1,
    // (undocumented)
    include = 0
}

// @public
class UnregisteredMethodError extends Error {
    constructor(cmd: any);
}

declare namespace web {
    export {
        AnyCaller,
        AnyEmitter,
        CalleeFrame,
        CallerFrame,
        CallerStatus,
        CpCallBase,
        CpCallOption,
        CpcController,
        CpcError,
        CpcFailAsyncRespondError,
        CpcFailRespondError,
        CpcFrameSource,
        Frame,
        FrameType,
        GenCallerOpts,
        MakeCallers,
        MakeEmitter,
        ParseObjectOption,
        RemoteCallError,
        RpcDecorator,
        RpcExposed,
        RpcFrame,
        RpcInterceptCall,
        RpcInterceptReturn,
        RpcService,
        ServeFnConfig,
        ServerStatus,
        ServiceDefineMode,
        UnregisteredMethodError,
        createJbodStreamFrameSource,
        manualDefineObject,
        rpcExclude,
        CpCall,
        WebStreamSuite,
        createWebSocketCpc,
        createWebStreamCpc,
        createWebsocketCpcOnOpen
    }
}

// @public (undocumented)
type WebStreamSuite = {
    readable: ReadableStream_2<Uint8Array>;
    writable: WritableStream_2<Uint8Array>;
};

// Warnings were encountered during analysis:
//
// dist/web.d.ts:41:5 - (ae-forgotten-export) The symbol "ReadableStream_2" needs to be exported by the entry point index.d.ts
// dist/web.d.ts:42:5 - (ae-forgotten-export) The symbol "WritableStream_2" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
